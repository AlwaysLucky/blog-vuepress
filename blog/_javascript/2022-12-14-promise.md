---
title: 手写Promise
date: 2022-11-27
tags:
  - 手写系列
summary: Promise
---

## Promise基本使用
```js
const p = new Promise((resolve, reject) => {
  resolve('ok')
  reject('error')
})
p.then(res => {
  console.log(res)
}, err => {
  console.log(err)
})
```
1. Promise接收一个函数，这个函数会立即执行
2. Promise状态不可逆
    - pending
    - fulfilled
    - rejected
3. 结果是resolve生效，忽略reject

## 基础实现
```js
const PENDING = 'pending'
const FULFILLED = 'fulfilled'
const REJECTED = 'rejected'

class myPromise{
  constructor(executor) {
    this.status = 'pending' // 保存当前处于哪一状态
    this.reason = undefined // 保存reject结果
    this.value = undefined  // 保存resolve结果

    const resolve = (value) => {
      console.log(value)
      this.value = value
    }

    const reject = (reason) => {
      console.log(reason)
      this.reason = reason
    }

    executor(resolve, reject)
  }
}

const p = new myPromise((resolve, reject) => {
  resolve('success')
  reject('fail')
  throw new Error('error')
})
```
问题：
1. resolve和reject都执行了
2. 最终status: rejected
3. 无法捕获主体异常
### 添加状态不可逆
```js
const resolve = (value) => {
  if(this.status === PENDING) {
    this.status = FULFILLED
    console.log(value)
    this.value = value
  }
}

const reject = (reason) => {
  if(this.status === PENDING) {
    this.status  = REJECTED
    console.log(reason)
    this.reason = reason
  }
}
```
### 捕获主体异常
```js
try {
  executor(resolve, reject)
} catch (error) {
  reject(error)
}
```

## 实现then
```js
then(onFulfilled, onRejected) {
  if(this.status === FULFILLED) {
    onFulfilled(this.value)
  }
  if(this.status === REJECTED) {
    onFulfilled(this.reason)
  }
}

// 测试
p.then(res => {
  console.log(res) // success
})
```
问题：
1. 无法处理主体异步问题
```js
const p = new myPromise((resolve, reject) => {
  setTimeout(() => {
    resolve('timeout')
  }, 1000)
})
p.then(res => {
  console.log('res', res) // 这里不会执行
})
```

### 解决异步问题
因为执行**then**的时候**status**的状态还是**pending**，所以就没办法执行**onFulfilled**,
可以先将then的回调先保存起来，在resolve或
```
```