---
title: 百题复习
date: 2023-07-02
tags:
  - recover
summary: vue复习
---

## 基础

### ajax fetch axios

> 三者都属于网络请求，基于不同纬度

1. Ajax 属于技术统称
2. Fetch，是一个具体的 API
3. Axios，第三方库

**XMLHttpRequest**

```js
function ajax(url) {
  const xhr = new XMLHttpRequest()
  xhr.open('GET', url, false)
  xhr.onreadystatechange = function () {
    if (xhr.readyState === 4) {
      if (xhr.status === 200) {
        console.log(xhr.responseText)
      }
    }
  }

  xhr.send(null)
}

ajax('http://tzhen.vip')
```

**fetch**

> ES6 新增 API，支持 Promise

```js
fetch('http://127.0.0.1:8888/user/login', {
  method: 'post',
  headers: {
    'Content-Type': 'application/x-www-form-urlencoded'
  },
  body: Qs.stringify({
    account: '18310612838',
    password: md5('1234567890')
  })
}).then(response => {
  console.log(response.json())
})

fetch('http://127.0.0.1:8888/user/list').then(response => {
  console.log(response.json())
})
```

**axios**

> Axios 是一个库，对 ajax 进行封装，支持 Promise

### 防抖节流

1. 节流：限制执行频率，有节奏的执行
2. 防抖：限制执行次数，多次的密集执行只执行最后一次
3. 节流关注过程，防抖关注结果

- [防抖&节流详解](/js/2022/11/27/debounce-throttle/)

### px % em rem vw/vh

1. px 绝对单位
2. % 相对于父元素
3. em: 如果当前元素有设置 font-size，则为当前 font-size 大小，否则根据父元素
4. rem：
5. vw
6. vh

### 什么时候不能用箭头函数

### TCP 三次握手和四次挥手

- [见 wireshark 三次握手详解](/browser/2022/07/25/tcp/)

### for in , for of, for await of

### offsetHeight, scrollHeight

### HTMLCollection 和 NodeList

- Dom 是一颗树，所有节点都是 Node
- Node 是 Element 的基类
- Element 是其他 HTML 元素的基类，如 HTMLDivElement

**Node 和 Element 的关系**

```js
class Node {}

class CharacterData extends Node {}
class Text extends CharacterData {}
class Comment extends CharacterData {}

class Element extends Node {}
class HTMLElement extends Element {}
class HTMLDivElement extends HTMLElement {}
```

```html
<div id="d1">
  <p>haha</p>
  <!--注释-->>
</div>

<script>
  const d1 = document.querySelector('#d1')
  console.log(d1.children instanceof HTMLCollection)
  console.log(d1.childNodes instanceof NodeList)
</script>
```

**结论**

1. HTMLCollection 是 Element 的集合
2. NodeList 是 Node 的集合

### computed vs watch

- [computed & watch 详解](/vue/2023/01/29/base/#computed-watch)

### Vue 通讯的几种方式

1. pros/emit（父子）
2. 自定义事件（事件总线）
3. $attrs/$listeners
   - $attrs: 容器对象，存放父组件传过来且子组件未使用 props 声明接收的数据
   - $listeners: 实现跨组件数据传递 中间组件v-on="$listeners"
   - inheritAttrs: false; 禁止在 html 标签上显示传过来的数据
4. $parent/$children|$refs
5. provide 和 inject（跨层级）

```js
// 父组件
provide: {
  info: 'hello'
}
// 使用data中的数据
provide() {
  return {
    info: computed(() => ***.value)
  }
}
// 子组件
inject: ['info']
```

6. vuex

### vuex action mutation

### 严格模式

1. 全局变量必须先声明
2. 禁止使用 width
3. 禁止创建 eval 作用域
4. 禁止 this 指向 window
5. 函数参数不能重名

### HTTP 跨域请求时为什么会发送 options 请求

> 跨域请求时，浏览器自动发出 options 请求（预检测），以检测服务端是否支 持

## 深度

### JS 内存泄漏

1. 什么是垃圾回收
2. 引用计数
3. 标记清除

### WeakMap WeakSet

见 coder 高级 JS

### vdom 真的快吗

1. vdom 与 js 直接操作 dom 相比，并没有原生操作快
2. 数据驱动视图要有合适的方案，不能全部 DOM 重建
3. vdom 是目前最合适的技术方案，不是因为快，而是合适

- 扩展：svelet，没有使用 vdom

### for vs forEach 哪个速度更快

- for 更快
- forEach 需要创建函数，函数有独立的作用域，开销更大

### Node 如何开启多进程，进程如何通讯

**为什么要开启多进程**

1.  开启多进程，能够充分利用多核 CPU 处理能力
2.  单进程的内存存储有上限，多进程能够分担压力

**开启多进程**

1.  child_process.fork
2.  cluster.fork
3.  send 和 on 传递消息

### JsBridge 原理

**webview**

> 是系统渲染网页的一个控件，可执行 javascript，可与页面 JavaScript 交互，实现混合开发

- Android 的 webview 内核
  1. 4.4 之前
  2. 4.4 之后采用了 chrome
- IOS 的 webview
  1. <ios8: UIWebView
  2. \>=ios8: WKWebView

#### Native 与 Webview通信
##### Native -> Webview
- Android
  1. <4.4: `loadUrl('javascript:' + jsCode)`；不支持回调
  2. \>=4.4:` evaluateJavascript('javascript:' + jsCode, new ValueCallback<String>() {})`； 可以获取返回值，支持回调
- IOS
  1. UIWebview: stringByEvaluatingJavascriptFromString
  2. WKWebView: evaluateJavascript:

##### WevView -> Native
**URL Schema**
1. web发送的请求都会经过webview组件，Native重写webview里的方法，拦截web发送的请求，对请求格式进行判断
2. 如果如何自定义URL Schema格式，则进行解析，调用原生Native方法
3. 如果不符合自定义URL Schema，则直接转发，请求真正的服务

* web发起请求的方式
1. a标签： 需用户主动操作
2. location.href：可能会引起页面跳转，丢失调用
3. ajax：Android没有相应的拦截方法
4. iframe.src：推荐

* 拦截请求
1. Android
    - shouldOverrideUrlLoading
2. IOS
    - UIWebview: shouldStartLoadWithRequest
    - WKWebView: decidePolicyForNavigationAction
> 优点：兼容好；缺点：URL长度限制且不直观，数据格式限制，发起请求耗时

**JS 注入**
1. Android
    - 4.2+: addJavascriptInterface
2. IOS
    - UIWebview: JavaScriptCore
    - WKWebView: WKScriptMessageHandler

### requestIdleCallback 和 requestAnimationFrame

- requestAnimationFrame: 每次渲染完都会执行（帧变化）, 高优先级
- requestIdleCallback: 空闲时执行, 低级先级

```js

```

### Vue 的每个生命周期都做了什么

1. beforeCreate

- `new Vue` 一个空白的 vue 实例
- `data` `method` 尚未初始化

2. crated

- 实例初始化完成，完成响应式绑定
- `data` `method` 已初始化完成

3. beforeMount

- 编译模版，调用`render`生成 vDom
- 还没有开始渲染 Dom

4. mounted

- 完成`Dom`渲染
- 组件创建完成

5. beforeUpdate（更新阶段）

- `data`发生变化之后，准备更新 Dom（尚未更新 Dom）

6. updated（更新阶段）

- `data`发生变化，且`Dom`更新完成
- 不要在`updated`中修改`data`，否则可能导致死循环

7. beforeUnmount (销毁阶段)

- 组件进入销毁阶段（尚未销毁）
- 可移除、解绑一些全局事件、自定义事件

8. mounted (销毁阶段)

- 组件已销毁
- 所有子组件已销毁

**keep-alive**

1. activated

- 缓存组件被激活

2. deactivated

- 缓存组件被隐藏

**Vue3 Composition API 生命周期与 vue2 有何区别**

- 用`setup`代替了`beforeCreated`、`created`
- 使用`Hooks`函数形式，如`mounted` -> `onMounted`

### Vue2 diff 和 Vue3 diff

1.  同层比较
2.  tag 不同，则删除重建
3.  子节点通过 key 区分

**vue2**

> 双端比较

**vue3**

> 最长递增子序列

**react**

> 仅右移

### Vue Router 的 MemoryHistory

**路由的三种模式**

1.  hash
2.  history
3.  abstract（node 中使用，路由地址不会发生变化）
    - vue2 中是 mode: abstract
    - vue3 中 history: createMemoryHistory()
