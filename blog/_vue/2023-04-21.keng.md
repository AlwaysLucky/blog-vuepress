---
title: vue踩坑记录
date: 2023-04-21
tags:
  - vue
summary: vue
---

### keep-alive
**问题描述**
设置了`keep-alive`的组件，`watch`事件不会销毁
1. `watch route`，离开当前页面，还是会`watch`到路由变化
2. `watch vuex`，也是同样的问题

**解决**
1. 方式一
```js
watch: {
  test() {
    if (this.$route.name !== 'test') return
  }
}
```
这种解决方法依赖于当前组件的`route name`，如果路由比较多，改动起来略麻烦

**方式二（mixin）**
```js
/* mixin.js */
data() {
  return {
    _currentPage: true
  }
},
deactivated() {
  this._currentPage = false
}
```

```js
/* page */
watch: {
  test() {
    if (this._currentPage !== true) return
  }
}
```
注意事项：
1. `mixin`定义的变量（_currentPage）有与其他`data`变量重复的风险
2. 仍然需要每个页面修改`watch`

### key值重复
key值重复导致数据不更新
1. 浏览器和安卓并没有此情况
2. ios存在不更新的情况· 

### 难点
#### 菜单联动
* 现象描述：点击菜单滚动到菜单对应的模块位置；
* 难点：菜单有一部分是条件渲染的，点击时需要知道当前菜单的位置
* 旧实现：根据条件动态计算当前索引位置；当有新增删除模块时，需要手动维护索引

**改进：**
  1. 在`updated`中获取已经渲染好的列表
  2. 遍历渲染好的列表为其动态设置`data-index`绑定索引
  3. 点击时为当前元素添加`class: active`，移除之前的`active`

**思路：**
> 这里过度依赖vue数据绑定，导致了索引更新变得复杂，反而使用以前的命令式编程更方便