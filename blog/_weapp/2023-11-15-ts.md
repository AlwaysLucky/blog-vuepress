---
title: TS学习笔记
date: 2023-11-15
summary: TS
---

## 数组 vs 元组
1. 数组
```ts
const list1: number[] = [1, 2, 3] // 方式一（推荐）
const list2: Array<number> = [1, 2, 3] // 方式二
const list3: (number|string)[] = [1, 3, '2'] // 使用联合类型声明多种类型
type User = { name: string; age: number } // 使用类型别名
const list4: User[] = [
  {
    name: 'litianzhen',
    age: 20
  }
]
```

2. 元组
```ts
// 数量类型固定
const userInfo: [string, string, number] = ['monkey', 'tiger', 100]
```

## 接口
```ts
interface Person {
  readonly firstName: string // readonly 只读属性
  lastName: string
  age?: number // 可选属性
  say(): string // 方法
  [prop: string]: // 索引签名 -> 绕开多余属性
}

function getFullName({firstName, lastName}: Arg) {
  return `${firstName} ${lastName}`
}
```
1. implements
```ts
interface Vegetables {
  color?: string
  type: string
}
class tomato implements Vegetables{
  color = 'red';
  type = 'vegetable'; // 必须声明type
}
```

2. extends
```ts
interface Tomato extends Vegetables {
  eat(): string
}
```

3. 定义函数类型
```ts
interface AddFunc {
  (num1: number, num2: number): number
}
const add: AddFunc = (num1, num2) => num1 + num2
```

## Class
### 修饰符
```ts
class Person {
    public name: string
    protected sex: string
    private age = 20
    sayHello() {
      console.log('hello')
    }
    constructor(name: string, sex: string) {
      this.name = name
      this.sex = sex
    }
  }

  class Student extends Person {
    constructor(name: string, sex: string) {
      super(name, sex)
    }

    getSex () {
      return this.sex // 子类继承中可以使用
    }
  }

  const p = new Person('tianzhen', 'man')
  console.log(p.sayHello())
  console.log(p.name)
  console.log(p.sex); // 不可访问
  console.log(p.age); // 不可访问

  const s = new Student('hongli', 'woman')
  console.log(s.name)
  console.log(s.getSex());
```
1. 如果没有使用修饰符，默认为**public**
2. **private**只能在自己类的内部使用
3. **protected**可以在被继承的子类中使用

### 简化写法
```ts
class Teacher {
  name: string;
  constructor(name: string) {
    this.name = name
  }
}
class Teacher {
  constructor(public name: string) {}
}

const t = new Teacher('litianzhen teacher')
console.log(t.name);
```

上面两种写法是等价的

### getter/setter
```ts
class Student {
  constructor(private _name: string) {}

  get name() {
    return this._name
  }

  set name(name) {
    this._name = 'hello ' + name
  }
}

const stu = new Student('tianzhen')
console.log(stu.name);
stu.name = 'hongli'
console.log(stu.name);
```

当不想暴露一些私有属性时，可使用**private**并提供**get/set**

### 单例
```ts
class Demo {
  private constructor(public name: string) {}
  private static instance: Demo
  static getInstance(name: string) {
    if (!this.instance) {
      this.instance = new Demo(name)
    }
    return this.instance
  }
}

const demo1 = Demo.getInstance('tianzhen')
const demo2 = Demo.getInstance('tianzhen1') // 无效，只能实例一次
console.log(demo1.name); // tianzhen
console.log(demo2.name); // tianzhen
console.log(demo1 === demo2); // true
```